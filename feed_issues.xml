<?xml version='1.0' encoding='UTF-8'?>
<rss version="2.0">
  <channel>
    <title>GitHub issues Feed</title>
    <link>https://github.com/username/repo/issues</link>
    <description>Recent issues from GitHub repo</description>
    <item>
      <title>[fix] inductor `split` lowering fails if `item()` is captured</title>
      <link>https://github.com/pytorch/pytorch/pull/123032</link>
      <description><![CDATA[<p>Fixes #122937</p>
<p>cc @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Sat, 30 Mar 2024 10:57:00 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/123032</guid>
    </item>
    <item>
      <title>[inductor] Move compile workers to a subprocess</title>
      <link>https://github.com/pytorch/pytorch/pull/122941</link>
      <description><![CDATA[<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* #123012<br />
* #123011<br />
* <strong>-&gt;</strong> #122941<br />
* #123010<br />
* #123009</p>
<p>In many environments using fork-based parallelism causes issues because user processes are not fork-safe.  This moves our parallel compile work pool into a subprocess that we control (that should be fork safe).</p>
<p>Perf run: https://github.com/pytorch/pytorch/actions/runs/8486887873</p>
<p>cc @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Thu, 28 Mar 2024 20:34:51 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122941</guid>
    </item>
    <item>
      <title>[AOTInductor] Support quantized linear on CPU with fbgemm</title>
      <link>https://github.com/pytorch/pytorch/pull/122939</link>
      <description><![CDATA[<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* <strong>-&gt;</strong> #122939</p>
<p>Summary:<br />
Added support for quantized linear on CPU with fbgemm.<br />
Specifically, for torch.ops.quantized.linear_unpacked_dynamic_fp16, we<br />
decompose it into two steps, pack weight, and fbgemm's qlinear with<br />
packed weight.</p>
<p>Test Plan:<br />
Included in commit.<br />
test_aot_inductor::test_quantized_linear</p>
<p>Reviewers:</p>
<p>Subscribers:</p>
<p>Tasks:</p>
<p>Tags:</p>
<p>cc @jgong5 @mingfeima @XiaobingSuper @sanchitintel @ashokei @jingxu10 @voznesenskym @penguinwu @EikanWang @Guobing-Chen @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>
<p>Differential Revision: <a href="https://our.internmc.facebook.com/intern/diff/D55512029">D55512029</a></p>]]></description>
      <pubDate>Thu, 28 Mar 2024 20:03:28 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122939</guid>
    </item>
    <item>
      <title>Inductor: aten.split_with_sizes.default: TypeError: Cannot convert symbols to int</title>
      <link>https://github.com/pytorch/pytorch/issues/122937</link>
      <description><![CDATA[<h3>üêõ Describe the bug</h3>
<p>Internal xref: https://fb.workplace.com/groups/6829516587176185/posts/7024545131006662</p>
<p>This program</p>
<p>```<br />
import torch<br />
import torch._dynamo.config</p>
<p>torch._dynamo.config.capture_scalar_outputs = True</p>
<p>@torch.compile()<br />
def f(x, il, jl):<br />
    i0, i1, i2 = il.tolist()<br />
    j0, j1, j2 = jl.tolist()<br />
    for i in [i0, i1, i2, j0, j1, j2]:<br />
        torch._check_is_size(i)<br />
    r = torch.zeros(x.item())<br />
    return torch.ops.aten.split_with_sizes.default(r, [i0 + j0, i1 + j1, i2 + j2])</p>
<p>f(torch.tensor(20), torch.tensor([2, 5, 3]), torch.tensor([3, 4, 3]))<br />
```</p>
<p>fails with</p>
<p>```<br />
  File "/data/users/ezyang/a/pytorch/torch/_inductor/lowering.py", line 1358, in split_with_sizes<br />
    return split(x, sizes, dim, clamp=False)<br />
  File "/data/users/ezyang/a/pytorch/torch/_inductor/lowering.py", line 298, in wrapped<br />
    out = decomp_fn(<em>args, </em>*kwargs)<br />
  File "/data/users/ezyang/a/pytorch/torch/_inductor/lowering.py", line 1340, in split<br />
    x_size = V.graph.sizevars.evaluate_static_shape(x.get_size()[dim])<br />
  File "/data/users/ezyang/a/pytorch/torch/_inductor/sizevars.py", line 394, in evaluate_static_shape<br />
    right = self.size_hint(left)<br />
  File "/data/users/ezyang/a/pytorch/torch/_inductor/sizevars.py", line 431, in size_hint<br />
    return int(out)<br />
  File "/home/ezyang/local/a/pytorch-env/lib/python3.10/site-packages/sympy/core/expr.py", line 320, in <strong>int</strong><br />
    raise TypeError("Cannot convert symbols to int")<br />
torch._dynamo.exc.BackendCompilerFailed: backend='inductor' raised:<br />
LoweringException: TypeError: Cannot convert symbols to int<br />
  target: aten.split_with_sizes.default<br />
  args[0]: TensorBox(StorageBox(<br />
    Pointwise(<br />
      'cpu',<br />
      torch.float32,<br />
      def inner_fn(index):<br />
          i0 = index<br />
          tmp0 = ops.constant(0, torch.float32)<br />
          return tmp0<br />
      ,<br />
      ranges=[u27],<br />
      origin_node=full,<br />
      origins={full}<br />
    )<br />
  ))<br />
  args[1]: [u21 + u24, u22 + u25, u23 + u26]</p>
<p>Set TORCH_LOGS="+dynamo" and TORCHDYNAMO_VERBOSE=1 for more information</p>
<p>You can suppress this exception and fall back to eager by setting:<br />
    import torch._dynamo<br />
    torch._dynamo.config.suppress_errors = True<br />
```</p>
<p>I think this is just the split_with_sizes lowering is written poorly, we don't actually need to get a hint for the input dim being split over if we have a list of splits, just use those splits directly.</p>
<h3>Versions</h3>
<p>main</p>
<p>cc @msaroufim @bdhirsh @anijain2305 @zou3519 @chauhang @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire</p>]]></description>
      <pubDate>Thu, 28 Mar 2024 19:33:10 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/issues/122937</guid>
    </item>
    <item>
      <title>Compile torch 1.12.1 from source using cuda 12.1</title>
      <link>https://github.com/pytorch/pytorch/issues/122936</link>
      <description><![CDATA[<h3>üêõ Describe the bug</h3>
<p>I am compiling torch 1.12.1 from source using cuda 12.1 and always get errors as follows, I  wonder whether torch version mismatch with that of cuda<br />
<img alt="image" src="https://github.com/pytorch/pytorch/assets/73052387/1944e19f-3fda-4524-b67f-04039bbf886e" /></p>
<h3>Versions</h3>
<p>Collecting environment information...<br />
```<br />
PyTorch version: N/A<br />
Is debug build: N/A<br />
CUDA used to build PyTorch: N/A<br />
ROCM used to build PyTorch: N/A</p>
<p>OS: Ubuntu 22.04.3 LTS (x86_64)<br />
GCC version: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0<br />
Clang version: Could not collect<br />
CMake version: version 3.26.4<br />
Libc version: glibc-2.35</p>
<p>Python version: 3.9.18 (main, Sep 11 2023, 13:41:44)  [GCC 11.2.0] (64-bit runtime)<br />
Python platform: Linux-5.15.0-101-generic-x86_64-with-glibc2.35<br />
Is CUDA available: N/A<br />
CUDA runtime version: 12.1.105<br />
CUDA_MODULE_LOADING set to: N/A<br />
GPU models and configuration: <br />
GPU 0: NVIDIA GeForce RTX 4090<br />
GPU 1: NVIDIA GeForce RTX 4090<br />
GPU 2: NVIDIA GeForce RTX 4090</p>
<p>Nvidia driver version: 535.161.07<br />
cuDNN version: Probably one of the following:<br />
/usr/lib/x86_64-linux-gnu/libcudnn.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_adv_infer.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_adv_train.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_cnn_infer.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_cnn_train.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_ops_infer.so.8.9.0<br />
/usr/lib/x86_64-linux-gnu/libcudnn_ops_train.so.8.9.0<br />
HIP runtime version: N/A<br />
MIOpen runtime version: N/A<br />
Is XNNPACK available: N/A</p>
<p>CPU:<br />
Architecture:                       x86_64<br />
CPU op-mode(s):                     32-bit, 64-bit<br />
Address sizes:                      52 bits physical, 57 bits virtual<br />
Byte Order:                         Little Endian<br />
CPU(s):                             40<br />
On-line CPU(s) list:                0-39<br />
Vendor ID:                          GenuineIntel<br />
Model name:                         Intel(R) Xeon(R) Silver 4416+<br />
CPU family:                         6<br />
Model:                              143<br />
Thread(s) per core:                 2<br />
Core(s) per socket:                 20<br />
Socket(s):                          1<br />
Stepping:                           7<br />
CPU max MHz:                        3900.0000<br />
CPU min MHz:                        800.0000<br />
BogoMIPS:                           4000.00<br />
Flags:                              fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf tsc_known_freq pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cat_l2 cdp_l3 invpcid_single intel_ppin cdp_l2 ssbd mba ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust sgx bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb intel_pt avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local split_lock_detect avx_vnni avx512_bf16 wbnoinvd dtherm ida arat pln pts hwp hwp_act_window hwp_epp hwp_pkg_req avx512vbmi umip pku ospke waitpkg avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg tme avx512_vpopcntdq la57 rdpid bus_lock_detect cldemote movdiri movdir64b enqcmd sgx_lc fsrm md_clear serialize tsxldtrk pconfig arch_lbr amx_bf16 avx512_fp16 amx_tile amx_int8 flush_l1d arch_capabilities<br />
Virtualization:                     VT-x<br />
L1d cache:                          960 KiB (20 instances)<br />
L1i cache:                          640 KiB (20 instances)<br />
L2 cache:                           40 MiB (20 instances)<br />
L3 cache:                           37.5 MiB (1 instance)<br />
NUMA node(s):                       1<br />
NUMA node0 CPU(s):                  0-39<br />
Vulnerability Gather data sampling: Not affected<br />
Vulnerability Itlb multihit:        Not affected<br />
Vulnerability L1tf:                 Not affected<br />
Vulnerability Mds:                  Not affected<br />
Vulnerability Meltdown:             Not affected<br />
Vulnerability Mmio stale data:      Not affected<br />
Vulnerability Retbleed:             Not affected<br />
Vulnerability Spec rstack overflow: Not affected<br />
Vulnerability Spec store bypass:    Mitigation; Speculative Store Bypass disabled via prctl and seccomp<br />
Vulnerability Spectre v1:           Mitigation; usercopy/swapgs barriers and __user pointer sanitization<br />
Vulnerability Spectre v2:           Mitigation; Enhanced IBRS, IBPB conditional, RSB filling, PBRSB-eIBRS SW sequence<br />
Vulnerability Srbds:                Not affected<br />
Vulnerability Tsx async abort:      Not affected</p>
<p>Versions of relevant libraries:<br />
[pip3] numpy==1.26.4<br />
[conda] blas                      1.0                         mkl<br />
[conda] magma-cuda121             2.6.1                         1    pytorch<br />
[conda] mkl                       2023.1.0         h213fc3f_46344<br />
[conda] mkl-include               2023.1.0         h06a4308_46344<br />
[conda] mkl-service               2.4.0            py39h5eee18b_1<br />
[conda] mkl_fft                   1.3.8            py39h5eee18b_0<br />
[conda] mkl_random                1.2.4            py39hdb19cb5_0<br />
[conda] numpy                     1.26.4           py39h5f9d8c6_0<br />
[conda] numpy-base                1.26.4           py39hb5e798b_0 <br />
<code>``</code><br />
`</p>]]></description>
      <pubDate>Thu, 28 Mar 2024 19:00:17 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/issues/122936</guid>
    </item>
    <item>
      <title>[fix] 'from' in python code generated by inductor, resulting in SyntaxError</title>
      <link>https://github.com/pytorch/pytorch/pull/122632</link>
      <description><![CDATA[<p><code>from</code> is  a python keyword.  Python code containing <code>aten.random.from</code> will result in syntax errors. This PR handle this special case in the codegen of inductor. </p>
<p>Although only <code>aten.random(_).</code>  has an <code>from</code> overload for now, all possible cases were handled.</p>
<p>Fixes #121621 </p>
<p>cc @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Mon, 25 Mar 2024 10:47:03 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122632</guid>
    </item>
    <item>
      <title>[Quant][Inductor] Enable lowering of qlinear-binary(-unary) fusion for X86Inductor</title>
      <link>https://github.com/pytorch/pytorch/pull/122593</link>
      <description><![CDATA[<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* #122667<br />
* <strong>-&gt;</strong> #122593<br />
* #122387<br />
* #122288</p>
<p><strong>Description</strong><br />
Lower the qlinear binary post op pattern to Inductor. Use post op sum (in-place) if the extra input has the same dtype as output. Otherwise, it uses binary add.</p>
<p><strong>Supported linear-binary(-unary) patterns</strong><br />
```<br />
    linear(X)   extra input<br />
           \   /<br />
            Add<br />
             |<br />
        Optional(relu)<br />
             |<br />
             Y</p>
<ol>
<li>
<p>int8-mixed-fp32<br />
+---+---------------+-----------+------------------------------+---------+<br />
| # | Add type      | Quant out | Pattern                      | Post op |<br />
+---+---------------+-----------+------------------------------+---------+<br />
| 1 | In-/out-place | Yes       | linear + fp32 -&gt; (relu) -&gt; q | add     |<br />
+---+---------------+-----------+------------------------------+---------+<br />
| 2 | In-/out-place | No        | linear + fp32 -&gt; (relu)      | sum     |<br />
+---+---------------+-----------+------------------------------+---------+</p>
</li>
<li>
<p>int8-mixed-bf16<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| # | X2 dtype | Add type      | Quant out | Pattern                                          | Post op |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 1 | BF16     | In-/out-place | Yes       | linear + bf16 -&gt; (relu) -&gt; to_fp32 -&gt; q          | add     |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 2 | BF16     | In-/out-place | No        | linear + bf16 -&gt; (relu)                          | sum     |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 3 | FP32     | Out-place     | Yes       | linear + fp32 -&gt; (relu) -&gt; q                     | add     |<br />
|   |          | In-place right|           |                                                  |         |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 4 | FP32     | Out-place     | No        | linear + fp32 -&gt; (relu)                          | sum     |<br />
|   |          | In-place right|           |                                                  |         |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 5 | FP32     | In-place left | Yes       | linear + fp32 -&gt; to_bf16 -&gt; relu -&gt; to_fp32 -&gt; q | add     |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
| 6 | FP32     | In-place left | No        | linear + fp32 -&gt; to_bf16 -&gt; (relu)               | add     |<br />
+---+----------+---------------+-----------+--------------------------------------------------+---------+<br />
```<br />
Note<br />
(1) The positions of linear and the extra input can be swapped.<br />
(2) we don't insert q-dq before the extra input of linear-add by recipe. But if q-dq is found at the<br />
extra input, we don't match that pattern because we cannot match all these patterns in 3 passes.</p>
</li>
</ol>
<p><strong>Test plan</strong><br />
python test/inductor/test_mkldnn_pattern_matcher.py -k test_qlinear_add<br />
python test/inductor/test_cpu_cpp_wrapper.py -k test_qlinear_add</p>
<p>cc @jgong5 @mingfeima @XiaobingSuper @sanchitintel @ashokei @jingxu10 @voznesenskym @penguinwu @EikanWang @Guobing-Chen @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Sun, 24 Mar 2024 23:49:36 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122593</guid>
    </item>
    <item>
      <title>[Quant][PT2E] Enable linear-binary(-unary) post-op recipe for X86Inductor quantizer</title>
      <link>https://github.com/pytorch/pytorch/pull/122387</link>
      <description><![CDATA[<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* #122667<br />
* #122593<br />
* <strong>-&gt;</strong> #122387<br />
* #122288</p>
<p>As the title<br />
<strong>Test plan</strong><br />
python test/test_quantization.py -k test_linear_binary</p>
<p>cc @jgong5 @mingfeima @XiaobingSuper @sanchitintel @ashokei @jingxu10 @voznesenskym @penguinwu @EikanWang @Guobing-Chen @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Wed, 20 Mar 2024 22:29:18 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122387</guid>
    </item>
    <item>
      <title>[inductor]re-enable cpu reduction ut</title>
      <link>https://github.com/pytorch/pytorch/pull/122289</link>
      <description><![CDATA[<p>Re-enable these two ut. I can pass these two ut on my local and we can see the status in the CI for this PR.</p>
<p>See the background about why they are disabled https://github.com/pytorch/pytorch/issues/93542, https://github.com/pytorch/pytorch/issues/87157.</p>
<p>After https://github.com/pytorch/pytorch/pull/115620. The reduction orders should be deterministic.<br />
However, the orders may not exactly same with ref path (<code>aten</code>). We may can set larger tolerance if they still cannot be passed in CI.</p>
<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* <strong>-&gt;</strong> #122289</p>
<p>cc @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Tue, 19 Mar 2024 23:43:23 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122289</guid>
    </item>
    <item>
      <title>[Quant][Inductor] Add qlinear_pointwise.binary op for X86Inductor backend</title>
      <link>https://github.com/pytorch/pytorch/pull/122288</link>
      <description><![CDATA[<p>Stack from <a href="https://github.com/ezyang/ghstack">ghstack</a> (oldest at bottom):<br />
* #122667<br />
* #122593<br />
* #122387<br />
* <strong>-&gt;</strong> #122288</p>
<p><strong>Description</strong><br />
Add qlinear_binary op for X86Inductor backend of quantization PT2E. It only supports <code>add</code> and <code>add_relu</code> now.<br />
It will use post op sum if the extra input has the same dtype as output. Otherwise, it uses binary add.<br />
<code>+-------------------+--------------+---------------+
| Extra input dtype | Output dtype | Post op       |
+-------------------+--------------+---------------+
| Fp32/bf16         | fp32/bf16    | sum           |
+-------------------+--------------+---------------+
| Fp32/bf16         | int8         | add           |
+-------------------+--------------+---------------+
| int8              | fp32/bf16    | not supported |
+-------------------+--------------+---------------+
| int8              | int8         | sum           |
+-------------------+--------------+---------------+</code></p>
<p><strong>Test plan</strong><br />
python test_quantization.py -k test_qlinear_add_pt2e<br />
python test_quantization.py -k test_qlinear_add_relu_pt2e</p>
<p>cc @jgong5 @mingfeima @XiaobingSuper @sanchitintel @ashokei @jingxu10 @voznesenskym @penguinwu @EikanWang @Guobing-Chen @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @peterbell10 @ipiszy @yf225 @chenyang78 @kadeng @muchulee8 @aakhundov @ColinPeppler @amjames @desertfire @chauhang</p>]]></description>
      <pubDate>Tue, 19 Mar 2024 23:40:10 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/122288</guid>
    </item>
    <item>
      <title>[HOO][dynamo] Contextual hints for torch.compile backends</title>
      <link>https://github.com/pytorch/pytorch/pull/121639</link>
      <description><![CDATA[<p><strong>Idea:</strong><br />
This is a draft for a feature that allows end-user to add contextual hints to chunks of code via HOO mechanism. </p>
<p>Such feature allows user to provide more structure and allow better programmability for the topology he creates as he would be able to provide additional hints to the torch.compile backend. One trivial example would be allowing end user to specify streams he would like specific parts of the topology to be ran on, assuming the backend that later optimizes it is able to take that information into account.</p>
<p>This is not intended to be final implementation (I guess) but more like a discussion opener.</p>
<p><strong>High level:</strong><br />
Implemented <strong>hinted_context</strong> higher-order-op that allows to specify function, arguments and a <strong>hint</strong>.</p>
<p>For the purpose of the draft, the <strong>hint</strong> currently is a JSON string that is going to be propagated into all ops within specified function. Such hints can be nested to provide even more structure to the operations.</p>
<p>Hints can be specified in two manners: <br />
- <strong>hints only inside the FWD code</strong>, in that scenario hints are going to be visible in FWD only<br />
- <strong>hints inside autograd overridden ops</strong>, in that scenario user can specify hints for FWD and BWD separately</p>
<p>Provided test shows various usages, including nested annotations for both cases above. Each test runs on dummy backend that just prints the hint metadata from the nodes:<br />
<img alt="image" src="https://github.com/pytorch/pytorch/assets/122799060/cce26bcf-9ffc-4b0b-ab92-524284e29e50" /></p>
<p>Fixes #118181</p>
<p>cc @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @chenyang78 @kadeng @chauhang</p>]]></description>
      <pubDate>Mon, 11 Mar 2024 07:20:07 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/pull/121639</guid>
    </item>
    <item>
      <title>nanogpt_generate: C++ compile times out, because the generated .cpp file is too large.</title>
      <link>https://github.com/pytorch/pytorch/issues/111227</link>
      <description><![CDATA[<p><code>nanogpt_generate</code> exists in torchbench before https://github.com/pytorch/benchmark/pull/1911,</p>
<p>Repro:<br />
```<br />
benchmarks/dynamo/torchbench.py --bfloat16 --accuracy --inference --device cuda --export-aot-inductor  --only nanogpt_generate</p>
<p>cc @ezyang @msaroufim @bdhirsh @anijain2305 @zou3519 @chauhang @voznesenskym @penguinwu @EikanWang @jgong5 @Guobing-Chen @XiaobingSuper @zhuhaozhe @blzheng @wenzhe-nrv @jiayisunx @chenyang78 @kadeng</p>]]></description>
      <pubDate>Fri, 13 Oct 2023 11:31:33 GMT</pubDate>
      <guid isPermaLink="true">https://github.com/pytorch/pytorch/issues/111227</guid>
    </item>
  </channel>
</rss>
